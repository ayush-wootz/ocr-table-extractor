<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hybrid OCR & Manual Entry Tool</title>

  <!-- Handsontable CSS and JS from CDN -->
  <link rel="stylesheet" type="text/css"
    href="https://cdn.jsdelivr.net/npm/handsontable@12.1.0/dist/handsontable.full.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/handsontable@12.1.0/dist/handsontable.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/string-similarity@4.0.4/umd/string-similarity.min.js"></script>
  <script src="https://unpkg.com/lucide@latest"></script>

  <style>
    /* --------------------- Global & Container Styles --------------------- */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Inter', sans-serif;
      background: #0d0d0d;
      color: #ffffff;
      overflow: hidden;
      /* Prevent body scroll */
    }

    #hybrid-tool-container {
      width: 100%;
      max-width: 100%;
      /* reduced to allow Handsontable padding */
      max-height: 758px;
      background-color: #0d0d0d;
      padding: 0 24px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      overflow-x: hidden;
      /* Prevent horizontal scroll on container */
    }

    #main-container {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    /* --------------------- Top Row Controls --------------------- */
    #top-row-controls {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-top: 16px;
      margin-bottom: 16px;
    }

    #tool-heading {
      font-size: 16px;
      font-weight: 500;
      color: #ffffff;
    }

    #top-row-right {
      display: flex;
      gap: 12px;
    }

    /* --------------------- Table Action Buttons --------------------- */
    #table-action-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      margin-bottom: 8px;
    }

    #table-action-buttons button {
      border: none;
      border-radius: 4px;
      padding: 6px 16px;
      font-size: 14px;
      cursor: pointer;
    }

    #extract-btn {
      background-color: #333;
      color: #fff;
    }

    #submit-btn {
      background-color: #fbbf24;
      color: #fff;
      font-weight: 700;
    }

    /* --------------------- Table & OCR Wrapper --------------------- */
    #table-and-ocr-wrapper {
      display: flex;
      flex: 1;
      overflow: visible;
    }

    /* --------------------- Handsontable Area --------------------- */
    #handsontable-container {
      flex: 1 1 auto;
      min-width: 0;
      margin-right: 16px;
      overflow-x: auto;
      overflow-y: hidden;
    }

    /* Override cell borders to #444 */
    #handsontable-container .wtBorder {
      border-color: #444 !important;
    }

    /* Wrap long text in cells */
    .handsontable td .htCore {
      white-space: normal !important;
      word-break: break-word;
      /* allow long words or strings to wrap */
      overflow-wrap: break-word;
    }

    /* Instructions bar above the table */
    .instructions {
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 12px 16px;
      margin-bottom: 12px;
      font-size: 0.85rem;
      line-height: 1.4;
      color: #ccc;
    }

    .instructions strong {
      color: #fff;
    }

    .help-icon {
      float: right;
      cursor: pointer;
      opacity: 0.7;
      position: relative;
      top: -3px;
    }

    .help-icon:hover {
      opacity: 1;
    }

    .help-popover {
      position: absolute;
      background: #fff;
      border: 2px solid #ddd;
      border-radius: 6px;
      padding: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      max-width: 100%;
      margin-top: 8px;
      display: none;
      color: #000;
    }

    /* OCR Overlay Panel Styles */
    #ocr-panel {
      position: fixed;
      top: 5%;
      left: 5vw;
      width: 90vw;
      height: 90%;
      background-color: #1a1a1a;
      border-radius: 8px;
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
      display: none;
      flex-direction: column;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
      border: 1px solid #444;
    }

    #ocr-panel.open {
      display: flex;
    }

    #ocr-panel-header {
      display: flex;
      justify-content: flex-end;
    }

    #ocr-close-btn {
      font-size: 20px;
      cursor: pointer;
    }

    #ocr-panel-body {
      margin-top: 16px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .dark-label {
      font-size: 14px;
      margin-bottom: 4px;
    }

    .upload-row {
      display: flex;
      justify-content: space-between;
      gap: 12px;
    }

    .upload-column {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .ocr-upload-area {
      border: 2px dashed #555;
      border-radius: 6px;
      padding: 6px;
      text-align: center;
      background: #fafafa;
      color: #000;
      position: relative;
      cursor: pointer;
      min-height: 180px;
      height: auto; 
    }

    .upload-clear-btn {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 16px;
      height: 16px;
      background: rgba(108,117,125,0.8);
      color: white;
      border: none;
      border-radius: 50%;
      font-size: 12px;
      line-height: 1;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      opacity: 0.7;
      transition: all 0.2s ease;
      z-index: 2;
    }

    .upload-clear-btn:hover {
      background: rgba(220,53,69,0.9);
      transform: scale(1.1);
    }

    .ocr-upload-area.has-file .upload-clear-btn {
      display: flex;
    }

    .ocr-upload-area input[type="file"] {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
      z-index: 1;
    }

    .ocr-image-preview {
      width: 100%;
      max-height: none;
      height: auto;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      background-color: #222;
      margin-top: 6px;
    }

    .ocr-image-preview img {
      max-width: 100%;
      height: auto;
      display: block;
    }

    .file-status {
      font-size: 0.75rem;
      margin-top: 4px;
      color: #28a745;
      display: none;
    }

    #ocr-process-btn {
      background-color: #007bff;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 8px 12px;
      cursor: pointer;
    }

    #ocr-process-btn:disabled {
      background-color: #444;
      cursor: not-allowed;
    }

    /* --------------------- Responsive Behavior --------------------- */
    @media (max-width: 960px) {
      #table-and-ocr-wrapper {
        flex-direction: column;
      }
      /* Responsive positioning for #ocr-panel removed */
      #handsontable-container {
        margin-right: 0;
      }
      #top-row-right {
        flex-wrap: wrap;
        gap: 8px;
      }
      #top-row-right button {
        width: 100%;
      }
    }
  </style>
</head>

<body>
  <div id="hybrid-tool-container">
    <div id="main-container">
      <!-- Top Row Controls -->
      <div id="top-row-controls">
        <div id="top-row-left">
          <span id="tool-heading">Add child parts/BO</span>
        </div>
        <!-- #top-row-right removed -->
      </div>

      <!-- Table and OCR Panel Wrapper -->
      <div id="table-and-ocr-wrapper">
        <!-- Handsontable Area (Left) -->
        <div id="handsontable-container">
          <!-- Instructions bar above the table -->
          <div class="instructions">
            ğŸ”¢ &lt; 20 rows | ğŸ” zoom &amp; sharp | ğŸš« no header
            <span id="help-icon" class="help-icon"><i data-lucide="info"></i></span>
            <div id="help-popover" class="help-popover">
              <strong>Good vs Bad Screenshot:</strong><br />
              <img src="sample-screenshot.png" style="width: 100%;" />
            </div>
          </div>
          <div id="table-action-buttons">
            <button id="extract-btn">Extract</button>
            <button id="submit-btn">Submit</button>
          </div>
          <!-- Handsontable placeholder (will be initialized via JS) -->
          <div id="hot" style="width: 100%; height: 400px;"></div>
        </div>

        <!-- OCR Slide-In Panel (Right) -->
        <div id="ocr-panel">
          <div id="ocr-panel-header">
            <span id="ocr-close-btn">Ã—</span>
          </div>
          <div id="ocr-panel-body">
            <div class="upload-row">
              <div class="upload-column">
                <label class="dark-label">Drawing Number</label>
                <div class="ocr-upload-area" data-column="Drawing Number">
                  <div class="upload-icon"><i data-lucide="upload"></i></div>
                  <div class="upload-label">Upload Image</div>
                  <button class="upload-clear-btn" onclick="clearUpload(this, event)">Ã—</button>
                  <input type="file" accept="image/*" />
                  <div class="file-status">âœ“ Uploaded</div>
                  <div class="ocr-image-preview"></div>
                </div>
              </div>
              <div class="upload-column">
                <label class="dark-label">Quantity</label>
                <div class="ocr-upload-area" data-column="Quantity">
                  <div class="upload-icon"><i data-lucide="upload"></i></div>
                  <div class="upload-label">Upload Image</div>
                  <button class="upload-clear-btn" onclick="clearUpload(this, event)">Ã—</button>
                  <input type="file" accept="image/*" />
                  <div class="file-status">âœ“ Uploaded</div>
                  <div class="ocr-image-preview"></div>
                </div>
              </div>
              <div class="upload-column">
                <label class="dark-label">Description</label>
                <div class="ocr-upload-area" data-column="Description">
                  <div class="upload-icon"><i data-lucide="upload"></i></div>
                  <div class="upload-label">Upload Image</div>
                  <button class="upload-clear-btn" onclick="clearUpload(this, event)">Ã—</button>
                  <input type="file" accept="image/*" />
                  <div class="file-status">âœ“ Uploaded</div>
                  <div class="ocr-image-preview"></div>
                </div>
              </div>
              <div class="upload-column">
                <label class="dark-label">Material</label>
                <div class="ocr-upload-area" data-column="Material">
                  <div class="upload-icon"><i data-lucide="upload"></i></div>
                  <div class="upload-label">Upload Image</div>
                  <button class="upload-clear-btn" onclick="clearUpload(this, event)">Ã—</button>
                  <input type="file" accept="image/*" />
                  <div class="file-status">âœ“ Uploaded</div>
                  <div class="ocr-image-preview"></div>
                </div>
              </div>
            </div>
            <div style="display: flex; justify-content: flex-end; margin-top: 16px;">
              <button id="ocr-process-btn" disabled>Process</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- â€”â€”â€” Begin Existing JavaScript Logic â€”â€”â€” -->
  <!-- (These <script> blocks are your original logic, left completely intact. 
       They include renderSpreadsheet(), addColumn(), sendDataToBackend(), OCR calls, etc.) -->

  <script>
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Global state & utility functions (unchanged from your original)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let currentStep = 1; // (unused now that we've collapsed Step 1/2 into one hybrid view)

    // Columnâ€toâ€Title mapping (used by renderSpreadsheet)
    const COLUMN_TITLES = {
      PartNumber: "Part Number",
      Quantity: "Quantity",
      Description: "Description",
      Material: "Material",
      "Matched Childpart": "Select Drawing Number",
      Type: "Type",
    };

    let spreadsheetData = [];
    let columnsList = [];
    let hot;
    window.windowChildParts = []; // expose on window for debugging

    // Fetch query-params (project, part, parentdrgnum) on load and fetch childParts
    window.addEventListener("DOMContentLoaded", async () => {
      const urlParams = new URLSearchParams(window.location.search);
      const project = urlParams.get("project");
      const partNumber = urlParams.get("part");
      const parentDrgNum = urlParams.get("parentdrgnum");
      if (!project || !partNumber || !parentDrgNum) {
        alert("Missing required query params: project/part/parentdrgnum");
        // Do not return; always initialize table even if params are missing
      } else {
        try {
          const resp = await fetch(
            "https://ocr-table-extractor.onrender.com/fetch-drawings",
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ project, part: partNumber }),
            }
          );
          const data = await resp.json();
          windowChildParts = data.rows.map((r) =>
            decodeURIComponent(r.drawingNumber || "")
          );
          console.log("âœ… Fetched windowChildParts:", window.windowChildParts);
        } catch (err) {
          console.error("Error fetching drawing data:", err);
        }
      }
      // Always initialize Handsontable, even if fetch fails or params are missing
      initializeHandsontable();
    });

    // Sequential character matching + bestâ€match utility
    function sequentialCharacterMatch(part, child) {
      if (!part || !child) return 0;
      const p = part.trim().toUpperCase();
      const c = child.trim().toUpperCase();
      if (p === c) return 1.0;
      if (c.includes(p)) return 0.99;
      let i = 0,
        j = 0,
        matched = 0;
      while (i < p.length && j < c.length) {
        if (p[i] === c[j]) {
          matched++;
          i++;
        }
        j++;
      }
      const baseSim = matched / p.length;
      const lengthDiff = Math.abs(p.length - c.length);
      const penalty = lengthDiff > 1 ? (lengthDiff - 1) * 0.1 : 0;
      const sim = Math.max(0, baseSim - penalty);
      if (matched === p.length) return Math.max(0.85, sim);
      return sim;
    }

    function findBestSequentialMatch(partText, drawingNumbers) {
      if (!partText || !drawingNumbers.length) {
        return { bestMatch: { target: "", rating: 0 }, allMatches: [] };
      }
      const matches = drawingNumbers.map((d) => ({
        target: d,
        rating: sequentialCharacterMatch(partText, d),
      }));
      matches.sort((a, b) => b.rating - a.rating);
      return { bestMatch: matches[0], allMatches: matches };
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Initialize Handsontable with 3 rows + 2 empty rows
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function initializeHandsontable() {
      // On first load, we want 5 rows of empty objects, each with just the 4 columns:
      // â€œSelect Drawing Numberâ€ (key â€œMatched Childpartâ€), â€œQuantityâ€, â€œDescriptionâ€, â€œMaterialâ€.
      spreadsheetData = [];
      for (let i = 0; i < 5; i++) {
        spreadsheetData.push({
          "Matched Childpart": "",
          Quantity: { text: "", confidence: 0 },
          Description: { text: "", confidence: 0 },
          Material: { text: "", confidence: 0 },
        });
      }

      // Only the 4 columns initially: mapping + 3 OCR
      columnsList = [
        "Type",
        "Matched Childpart",
        "Quantity",
        "Description",
        "Material",
      ];

      renderSpreadsheet();
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // renderSpreadsheet (combines OCR columns + mapping columns in one view)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function renderSpreadsheet() {
      // Prepare column definitions for Handsontable
      const drawingOptions = windowChildParts.slice(); // from fetched backend
      console.log("ğŸ” renderSpreadsheet: drawingOptions =", drawingOptions);
      const columns = columnsList.map((key) => {
        const title = COLUMN_TITLES[key] || key;
        const isMatched = key === "Matched Childpart";
        const isType = key === "Type";
        const isOCRcol = ["PartNumber", "Quantity", "Description", "Material"].includes(
          key
        );

        return {
          data: isMatched || isType ? key : `${key}.text`,
          title,
          type: isMatched || isType ? "dropdown" : "text",
          editor: isMatched
            ? "autocomplete"
            : isType
              ? "dropdown"
              : "text",
          source: isMatched
            ? ["", ...drawingOptions]
            : isType
              ? ["", "Child Part", "BO"]
              : undefined,
          strict: false,
          allowInvalid: true,
          readOnly: false, // all columns remain editable
          renderer: function (hotInstance, td, row, col, prop, value, cellProps) {
            if (isMatched || isType) {
              // dropdown renderer for mapping columns
              Handsontable.renderers.DropdownRenderer.apply(this, arguments);
              if (isMatched && value && value.toString().trim() !== "") {
                // lowâ€similarity warning on mapping in real time
                const rowData = hotInstance.getSourceDataAtRow(row);
                const partCell = rowData["PartNumber"];
                const partText = partCell?.text || "";
                if (partText) {
                  const sim = sequentialCharacterMatch(partText, value.toString());
                  if (sim < 0.95) {
                    td.classList.add("low-similarity-cell");
                  } else {
                    td.classList.remove("low-similarity-cell");
                  }
                }
              } else {
                td.classList.remove("low-similarity-cell");
              }
            } else {
              // OCR columns: color by confidence
              Handsontable.renderers.TextRenderer.apply(this, arguments);
              const rowData = hotInstance.getSourceDataAtRow(row);
              const cellObj = rowData[key];  // the { text, confidence } you stored

              if (cellObj && typeof cellObj === "object") {
                const conf = parseFloat(cellObj.confidence || 0);
                // Only apply a background if confidence > 0;
                // otherwise leave it blank (white).
                if (conf > 0) {
                  if (conf >= 0.95) {
                    td.style.backgroundColor = "rgba(76, 175, 80, 0.2)";
                  } else if (conf >= 0.8) {
                    td.style.backgroundColor = "rgba(255, 152, 0, 0.2)";
                  } else {
                    td.style.backgroundColor = "rgba(244, 67, 54, 0.2)";
                  }
                } else {
                  // No coloring when confidence is zero (empty cell)
                  td.style.backgroundColor = "";
                }
              }
            }
          },
        };
      });

      // Destroy any existing Handsontable instance
      const container = document.getElementById("hot");
      if (hot) {
        hot.destroy();
      }

      // Reâ€create with our new columns + data
      hot = new Handsontable(container, {
        data: spreadsheetData,
        columns,
        colHeaders: columnsList.map((k) => COLUMN_TITLES[k]),
        rowHeaders: true,
        minSpareRows: 1,
        contextMenu: ["remove_row", "copy", "paste"],
        dropdownMenu: true,
        filters: true,
        autoColumnSize: true, // â† allow text to wrap
        wordWrap: true,
        autoRowSize: true,
        // autoWrapRow: true,
        manualColumnResize: true,
        outsideClickDeselects: true,
        licenseKey: "non-commercial-and-evaluation",
        afterSelectionEnd: function (r, c, r2, c2) {
          setTimeout(() => {
            document
              .querySelectorAll('.wtBorder.current[style*="display: block"]')
              .forEach((border) => {
                const style = border.getAttribute("style");
                if (style.includes("width: 4px")) {
                  border.setAttribute("style", style.replace("width: 4px", "width: 1px"));
                }
                if (style.includes("height: 4px")) {
                  border.setAttribute("style", style.replace("height: 4px", "height: 1px"));
                }
              });
          }, 0);
        },
      });

      // Reâ€attach the â€œafterChangeâ€ hook to mark edited cells & autoâ€populate â€œTypeâ€
      hot.addHook("afterChange", (changes, source) => {
        if (source !== "edit" || !changes) return;
        changes.forEach(([row, prop, oldVal, newVal]) => {
          if (oldVal === newVal) return;
          const colIndex = hot.propToCol(prop);
          hot.setCellMeta(row, colIndex, "className", "edited-cell");

          // If user changed â€œMatched Childpartâ€, autoâ€populate â€œTypeâ€
          if (prop === "Matched Childpart") {
            const typeColIdx = hot.propToCol("Type");
            if (typeColIdx !== -1) {
              if (newVal && newVal.toString().trim() !== "") {
                hot.setDataAtCell(row, typeColIdx, "Child Part", "auto-type-population");
              } else {
                hot.setDataAtCell(row, typeColIdx, "BO", "auto-type-population");
              }
            }
          }
        });
        hot.render();
      });
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // addColumn: used by OCR processing to inject a new column's OCR data
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function addColumn(newColumnData, label) {
      // If this column is not yet in columnsList, add it (at the end).
      if (!columnsList.includes(label)) {
        columnsList.push(label);
        // If injecting PartNumber, also ensure mapping columns exist
        if (label === "PartNumber") {
          console.log("ğŸ” addColumn: received OCR data for PartNumber, bestâ€match list =", window.windowChildParts);
          if (!columnsList.includes("Matched Childpart")) {
            columnsList.push("Matched Childpart");
          }
          if (!columnsList.includes("Type")) {
            columnsList.push("Type");
          }
        }
      }

      // Now update spreadsheetData for this column without reordering others
      for (let i = 0; i < newColumnData.length; i++) {
        const text = newColumnData[i]?.text || "";
        const confidence = newColumnData[i]?.confidence || 0;
        if (!spreadsheetData[i]) {
          spreadsheetData[i] = {};
        }

        spreadsheetData[i][label] = { text, confidence };

        // If injecting PartNumber, autoâ€compute the match & Type
        // if (label === "PartNumber") {
        //   const drawingMatches = windowChildParts.slice();
        //   const best = findBestSequentialMatch(text, drawingMatches);
        //   const matchText = best.bestMatch.rating > 0.85 ? best.bestMatch.target : "";
        //   // Store match as plain string
        //   spreadsheetData[i]["Matched Childpart"] = matchText;
        //   spreadsheetData[i]["_similarityScore"] = best.bestMatch.rating;
        //   spreadsheetData[i]["Type"] = matchText ? "Child Part" : "BO";
        // }
        
        if (label === "PartNumber") {
          // Get drawing numbers from the windowChildParts
          const drawingMatches = Array.isArray(window.windowChildParts) 
            ? window.windowChildParts.slice() 
            : [];
          
          // Debug log to see if we have drawing matches
          console.log(`Processing PartNumber "${text}" with ${drawingMatches.length} possible matches`);
          
          // Find the best match
          const best = findBestSequentialMatch(text, drawingMatches);
          
          // Debug log to see the best match and its rating
          console.log("Best match:", best.bestMatch.target, "with rating:", best.bestMatch.rating);
          
          // Only use the match if it exceeds the threshold
          const matchText = best.bestMatch.rating > 0.85 ? best.bestMatch.target : "";
          
          // Debug log to see what we're setting
          console.log("Setting Matched Childpart to:", matchText || "(empty string)");
          
          // Only set the match if it's not already manually selected
          if (!spreadsheetData[i]["Matched Childpart"] || spreadsheetData[i]["Matched Childpart"] === "") {
            spreadsheetData[i]["Matched Childpart"] = matchText; // This should be an empty string if no good match
          }
          
          // Store the similarity score for reference
          spreadsheetData[i]["_similarityScore"] = best.bestMatch.rating;
          
          // Set Type based on whether we found a match
          if (!spreadsheetData[i]["Type"] || spreadsheetData[i]["Type"] === "") {
            spreadsheetData[i]["Type"] = matchText ? "Child Part" : "BO";
          }
        }
        
      }   
   

      renderSpreadsheet();
    }


// Add this debugging function somewhere in your code
window.diagnoseBestMatch = function(partNumber) {
  if (!partNumber || !windowChildParts.length) {
    console.log("Cannot diagnose - missing partNumber or windowChildParts");
    return;
  }
  
  console.log(`Diagnosing matches for part: "${partNumber}"`);
  
  // Get top 5 matches
  const matches = windowChildParts.map(d => ({
    target: d,
    rating: sequentialCharacterMatch(partNumber, d)
  }));
  
  matches.sort((a, b) => b.rating - a.rating);
  const top5 = matches.slice(0, 5);
  
  console.log("Top 5 matches:");
  top5.forEach((m, i) => {
    console.log(`${i+1}. "${m.target}" - rating: ${m.rating}`);
  });
  
  console.log(`Best match would be selected: ${top5[0].rating > 0.85 ? 'YES' : 'NO'}`);
  console.log(`Selected value: "${top5[0].rating > 0.85 ? top5[0].target : ''}"`);
};

// Call this function with a sample part number to see matching results
// diagnoseBestMatch("SP00395"); // Example - you can call this from the console

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // OCR Uploads: Multiple zones, event delegation, state per column
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const uploads = document.querySelectorAll(".ocr-upload-area");
    const fileStates = {};

    uploads.forEach(area => {
      const input = area.querySelector("input");
      const status = area.querySelector(".file-status");
      const preview = area.querySelector(".ocr-image-preview");
      const column = area.dataset.column;

      input.addEventListener("change", () => {
        const file = input.files[0];
        if (!file) return;

        fileStates[column] = file;
        status.style.display = "inline-block";
        const reader = new FileReader();
        reader.onload = (e) => {
          preview.innerHTML = `<img src="${e.target.result}" alt="Preview"/>`;
          area.classList.add("has-file");
        };
        reader.readAsDataURL(file);

        document.getElementById("ocr-process-btn").disabled = Object.keys(fileStates).length === 0;
      });
    });

    function clearUpload(buttonEl, event) {
      if (event) event.stopPropagation();

      const area = buttonEl.closest(".ocr-upload-area");
      const input = area.querySelector("input");
      const preview = area.querySelector(".ocr-image-preview");
      const status = area.querySelector(".file-status");
      const column = area.dataset.column;

      if (input) input.value = "";
      if (preview) preview.innerHTML = "";
      if (status) status.style.display = "none";

      area.classList.remove("has-file");
      delete fileStates[column];

      document.getElementById("ocr-process-btn").disabled = Object.keys(fileStates).length === 0;
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // OCR Processing Handler: triggered when user clicks â€œProcessâ€ in OCR panel
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    document.getElementById("ocr-process-btn").addEventListener("click", async () => {
      const processBtn = document.getElementById("ocr-process-btn");
      processBtn.disabled = true;

      const columnKeyMap = {
        "Drawing Number": "Matched Childpart",
        "Quantity": "Quantity",
        "Description": "Description",
        "Material": "Material",
      };

      for (const label in fileStates) {
        const formData = new FormData();
        formData.append("image", fileStates[label]);
        formData.append("mode", "table");
        formData.append("column", columnKeyMap[label]);

        try {
          const resp = await fetch("https://ocr-table-extractor.onrender.com", {
            method: "POST",
            body: formData,
          });
          const data = await resp.json();
          if (data.table && Array.isArray(data.table)) {
            addColumn(data.table, columnKeyMap[label]);
          }
        } catch (err) {
          console.error("Error OCR for", label, err);
        }
      }

      // Clear preview and fileStates after processing
      uploads.forEach(area => {
        area.querySelector(".file-status").style.display = "none";
        area.querySelector(".ocr-image-preview").innerHTML = "";
        area.querySelector("input").value = "";
      });

      Object.keys(fileStates).forEach(k => delete fileStates[k]);
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // OCR Panel Toggle: Extract button opens, Close (X) closes
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    document.getElementById("extract-btn").addEventListener("click", () => {
      const panel = document.getElementById("ocr-panel");
      panel.classList.add("open");
    });
    document.getElementById("ocr-close-btn").addEventListener("click", () => {
      const panel = document.getElementById("ocr-panel");
      panel.classList.remove("open");
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Show/Hide help popover
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    document.getElementById("help-icon").addEventListener("click", () => {
      const pop = document.getElementById("help-popover");
      pop.style.display = pop.style.display === "none" ? "block" : "none";
    });
    document.addEventListener("click", (e) => {
      if (!e.target.closest("#help-icon")) {
        document.getElementById("help-popover").style.display = "none";
      }
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // â€œSubmitâ€ button simply calls your existing sendDataToBackend()
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    document.getElementById("submit-btn").addEventListener("click", () => {
      sendDataToBackend();
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Existing sendDataToBackend() function (unchanged from your original)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async function sendDataToBackend() {
      const addDataBtn = document.getElementById("submit-btn");
      const originalText = addDataBtn.textContent;
      try {
        // Provide some visual feedback (you can customize as needed)
        addDataBtn.disabled = true;
        addDataBtn.textContent = "Sending...";
        // Validate required fields:
        const validation = validateRequiredFields();
        if (!validation.isValid) {
          alert(
            `Missing Required Fields:\n${validation.missingFields.join(
              ", "
            )}\nRequired fields:\n- Part Number, Quantity, Type (always required)\n- Select Drawing Number if Type = â€œChild Partâ€`
          );
          addDataBtn.textContent = originalText;
          return;
        }

        const urlParams = new URLSearchParams(window.location.search);
        const project = urlParams.get("project");
        const parentDrawingNumber = urlParams.get("parentdrgnum");
        const partNumber = urlParams.get("part");
        if (!project || !parentDrawingNumber || !partNumber) {
          throw new Error("Missing required URL params");
        }

        // Build ChildParts & BO arrays
        const childPartsData = [];
        const boData = [];
        spreadsheetData.forEach((row) => {
          const frontendPN = row.PartNumber?.text?.trim();
          const qty = row.Quantity?.text?.trim();
          const type = row.Type?.trim();
          if (!frontendPN && !qty) return;
          if (!frontendPN || !qty || !type) return;
          if (type === "Child Part") {
            childPartsData.push({
              quantity: qty,
              description: row.Description?.text?.trim() || "",
              material: row.Material?.text?.trim() || "",
              drawingNumber: row["Matched Childpart"] || "",
            });
          } else if (type === "BO") {
            const matched = row["Matched Childpart"]?.trim();
            boData.push({
              quantity: qty,
              description: row.Description?.text?.trim() || "",
              material: row.Material?.text?.trim() || "",
              boughtoutPartNumber: matched || frontendPN,
            });
          }
        });

        let successful = 0,
          total = 0;
        if (childPartsData.length) {
          total++;
          const respChild = await fetch(
            "https://ocr-table-extractor.onrender.com/add-child-parts",
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                rows: childPartsData,
                project,
                parentDrawingNumber,
                partNumber,
              }),
            }
          );
          if (!respChild.ok) {
            throw new Error(`Failed to add Child Parts: ${await respChild.text()}`);
          }
          successful++;
        }
        if (boData.length) {
          total++;
          const respBo = await fetch(
            "https://ocr-table-extractor.onrender.com/add-bo-parts",
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                rows: boData,
                project,
                parentDrawingNumber,
                partNumber,
              }),
            }
          );
          if (!respBo.ok) {
            throw new Error(`Failed to add BO Parts: ${await respBo.text()}`);
          }
          successful++;
        }

        if (successful === total && total > 0) {
          alert(
            `Data added successfully!\n- Child Parts: ${childPartsData.length}\n- BO Parts: ${boData.length}`
          );
        } else {
          throw new Error("No data was processed");
        }
      } catch (error) {
        console.error("âŒ Error sending data:", error);
        alert(`Error adding data: ${error.message}`);
      } finally {
        addDataBtn.disabled = false;
        addDataBtn.textContent = "Submit";
      }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // validateRequiredFields (unchanged)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function validateRequiredFields() {
      const missingFields = [];
      let hasValidRow = false;
      spreadsheetData.forEach((row, index) => {
        const partPN = row.PartNumber?.text?.trim();
        const qty = row.Quantity?.text?.trim();
        const type = row.Type?.trim();
        if (!partPN && !qty) return;
        hasValidRow = true;
        if (!partPN) missingFields.push(`Row ${index + 1}: Part Number`);
        if (!qty) missingFields.push(`Row ${index + 1}: Quantity`);
        if (!type) missingFields.push(`Row ${index + 1}: Type`);
        if (type === "Child Part" && !row["Matched Childpart"]) {
          missingFields.push(`Row ${index + 1}: Select Drawing Number`);
        }
      });
      return { isValid: hasValidRow && missingFields.length === 0, missingFields };
    }
  </script>
  <!-- â€”â€”â€” End Existing JavaScript Logic â€”â€”â€” -->
</body>

</html>
