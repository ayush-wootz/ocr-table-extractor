<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bulk Add - Column</title>

  <!-- Handsontable CSS and JS from CDN -->
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/handsontable@12.1.0/dist/handsontable.full.min.css">
  <script src="https://cdn.jsdelivr.net/npm/handsontable@12.1.0/dist/handsontable.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/string-similarity@4.0.4/umd/string-similarity.min.js"></script>
  <script src="https://unpkg.com/lucide@latest"></script>
  
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    
    .container {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    /* Header with logo and title */
    .header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .logo {
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
    }

    .logo::before {
      content: '‚ú®';
      font-size: 18px;
      filter: brightness(1.2);
    }

    .header h3 {
      margin: 0;
      font-size: 1.1rem;
      color: #333;
      font-weight: 500;
    }

    /* Instructions section */
    .instructions {
      background: #f8f9ff;
      border: 1px solid #e1e5f2;
      border-radius: 6px;
      padding: 12px 16px;
      margin-bottom: 20px;
      font-size: 0.85rem;
      line-height: 1.4;
      color: #4a5568;
    }

    .instructions strong {
      color: #2d3748;
    }

    .sample-link {
      color: #667eea;
      text-decoration: none;
      font-weight: 500;
    }

    .sample-link:hover {
      text-decoration: underline;
    }
    
/*     .secondary-button {
      background-color: #ccc;
      color: #333;
      border: none;
      padding: 8px 16px;
      border-radius: 5px;
      cursor: pointer;
      margin-bottom: 10px;
    }
    .secondary-button:hover {
      opacity: 0.8;
    } */

    #add-data-btn {
      background: #007bff;  /* Same color as Process Image */
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      margin: 10px 0;
      transition: background-color 0.3s ease;
    }
    
    #add-data-btn:hover:not(:disabled) {
      background: #0056b3;  /* Same hover color as Process Image */
    }
    
    #add-data-btn:disabled {
      background: #ccc;
      color: #666;
      cursor: not-allowed;
    }
    
    /* Hidden mode select - keeps default functionality */
    #mode-select {
      display: none;
    }

    /* 2x2 Grid Layout - Larger areas to fill space */
    .upload-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      gap: 12px;
      margin-bottom: 20px;
      max-width: 320px;
      margin-left: auto;
      margin-right: auto;
    }

    /* Process button and preview layout */
    .process-preview-container {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 15px;
      align-items: start;
      margin-bottom: 20px;
    }

    .process-section {
      display: flex;
      justify-content: flex-end;
    }

    .upload-area {
      position: relative;
      border: 2px dashed #ccc;
      border-radius: 6px;
      padding: 8px;
      text-align: center;
      background: #fafafa;
      transition: all 0.2s ease;
      cursor: pointer;
      min-height: 55px;
      max-height: 65px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      box-sizing: border-box;
    }

    /* Subtle upload icon styling */
    .upload-icon {
      color: #9ca3af;
      margin-bottom: 2px;
      transition: all 0.3s ease;
    }
    
    .upload-icon i {
      width: 12px;
      height: 12px;
    }
    
    .upload-area:hover .upload-icon {
      color: #6b7280;
    }
    
/*     .upload-area.has-file .upload-icon {
      color: #10b981;
    } */
    

    .upload-clear-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 12px;
      height: 12px;
      background: rgba(108, 117, 125, 0.8);
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 8px;
      font-weight: bold;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
      line-height: 1;
      opacity: 0.7;
      transition: all 0.2s ease;
    }

    .upload-clear-btn:hover {
      background: rgba(220, 53, 69, 0.9);
      opacity: 1;
      transform: scale(1.1);
    }

    .upload-area.has-file .upload-clear-btn {
      display: flex;
    }

    .upload-area:hover {
      border-color: #007bff;
      background: #f0f8ff;
      transform: scale(1.05);
    }

    .upload-area.dragover {
      border-color: #0056b3;
      background: #e6f3ff;
      box-shadow: 0 0 15px rgba(0, 123, 255, 0.4);
      transform: scale(1.1);
    }

    .upload-area.nearby {
      border-color: #007bff;
      background: #f0f8ff;
      transform: scale(1.05);
      box-shadow: 0 0 10px rgba(0, 123, 255, 0.2);
    }

    .upload-area.has-file {
      border-color: #28a745;
      border-style: solid;
      background: #f8fff9;
    }

    .upload-label {
      font-weight: normal;
      margin-bottom: 3px;
      font-size: 0.8rem;
      line-height: 1.1;
    }

    .required {
      color: #dc3545;
      margin-left: 2px;
    }

    .upload-area input[type="file"] {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
      z-index: 2;
    }

    .file-status {
      font-size: 0.7rem;
      color: #28a745;
      font-weight: bold;
      margin-top: 3px;
      line-height: 1;
    }

    /* highlight user-edited cells */
    .edited-cell {
      position: relative;
    }
    
    .edited-cell::after {
      content: '‚Ä¢';
      position: absolute;
      top: 1px;
      right: 1px;
      color: #607D8B; /* Blue-gray */
      font-size: 12px;
      font-weight: bold;
      pointer-events: none;
      z-index: 10;
    }    
    
    #process-btn {
      background: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      margin: 10px 0;
      transition: background-color 0.3s ease;
    }
    
    #process-btn:hover:not(:disabled) {
      background: #0056b3;
    }

    #process-btn:disabled {
      background: #ccc;
      color: #666;
      cursor: not-allowed;
    }
    
    /* Preview container - hidden by default */
    #image-preview {
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
      position: relative;
      display: block; /* Hidden by default */
      min-width: 150px;  /* Minimum size */
      max-width: min(400px, 90vw);  /* Larger maximum */
      width: fit-content; /* Adapts to content */
    }
    /* Only show when has image */
/*     #image-preview.has-image {
      display: block; 
    } */
    
    #image-preview img {
      max-width: 100%; /* Responsive within smaller container */
      height: auto;
      display: block;
      margin-top: 10px;
      width: auto; /* Let image determine its own width within max-width */
    }

    .preview-remove-btn {
      position: absolute;
      top: 15px;
      right: 15px;
      width: 20px;
      height: 20px;
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 12px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .preview-remove-btn:hover {
      background: #c82333;
    }

    /* Responsive design */
    @media (max-width: 400px) {
      .upload-grid {
        grid-template-columns: 1fr;
        grid-template-rows: repeat(4, 1fr);
      }
    }

    /* Style the autocomplete dropdown container */
    .handsontableInputHolder {
/*       border: 1px solid #2196f3 !important; */
      border-radius: 3px !important;
      box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3) !important;
      background: white !important;
      margin-top: 2px !important;
      max-width: 300px !important;
    }
    
    /* Style the autocomplete dropdown table */
    .handsontableInputHolder .htCore {
      border: none !important;
    }
    
    .handsontableInputHolder td {
      border-color: #f0f0f0 !important;
      padding: 2px 6px !important;
      line-height: 1.1 !important;
    }
    
    .handsontableInputHolder tr:hover td {
      background-color: #e3f2fd !important;
    }
    
    .handsontableInputHolder .current td {
      background-color: #2196f3 !important;
      color: white !important;
    }
    
    /* Fix editor width to prevent background text showing */
    .handsontable .handsontableInput {
      width: 100% !important;
      box-sizing: border-box !important;
    }
    
    /* Remove specific extra border types */
    .handsontable .wtBorder.corner,
    .handsontable .wtBorder.fill {
      display: none !important; /* Hide these extra border types */
    } 
        
        
    /* Force clean selection transitions */
    .handsontable td {
      border-right: 1px solid #ccc !important; /* Keep vertical lines */
      border-bottom: 1px solid #ccc !important; /* Keep horizontal lines */
      transition: none !important;
    }


.help-icon {
  margin-left: 8px;
  cursor: pointer;
  opacity: 0.7;
  transition: opacity 0.2s ease;
  display: inline-flex;
  align-items: center;
  vertical-align: middle; /* Add this for text alignment */
}

.help-icon i {
  width: 10px;  /* Reduced from 14px to match text size */
  height: 10px; /* Reduced from 14px to match text size */
  color: #111111;
  vertical-align: baseline; /* Align with text baseline */
}

.help-icon:hover {
  opacity: 1;
}

.help-icon:hover i {
  color: #6b7280;
}

.help-popover {
  position: absolute;
  background: white;
  border: 2px solid #ddd;
  border-radius: 6px;
  padding: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  z-index: 1000;
  max-width: 100%;
  margin-top: 8px;
}     
 
    
    /* Low similarity warning - just icon */
    .low-similarity-cell {
      position: relative;
    }

    .low-similarity-cell::after {
      content: '‚ö†Ô∏è';
      position: absolute;
      top: 1px;
      right: 1px;
      font-size: 11px;
      z-index: 10;
      pointer-events: none;
    }
  
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="logo"></div>
      <h3>Upload Column ScreenShots</h3>
    </div>

    <div class="instructions">
        üî¢ < 20 rows | üîç zoom & sharp | üö´ no headers
        <span id="help-icon" class="help-icon"> <i data-lucide="info"></i> </span>
        <!-- Add the popover right after instructions -->
        <div id="help-popover" class="help-popover" style="display: none;">
          <strong>Good vs Bad Screenshot:</strong><br>
          <img src= "sample-screenshot.png" style="width: 100%;">
        </div>
    </div>

    <!-- Hidden but functional mode select -->
    <select id="mode-select">
      <option value="table" selected>Column-by-Column Table Extract</option>
      <option value="quick">Quick Text Copy (Paragraph)</option>
    </select>
    
    <div class="upload-grid">
      <!-- Part Number -->
      <div class="upload-area" id="area-partNumber" data-column="partNumber">
        <button class="upload-clear-btn" onclick="clearUpload('partNumber', event)">√ó</button>
        <div class="upload-icon">
          <i data-lucide="upload"></i>
        </div>
        <div class="upload-label" id="label-partNumber">Part Number <span class="required">*</span></div>
        <input type="file" id="upload-partnumber" accept="image/*" />
        <div class="file-status" id="status-partNumber" style="display: none;">‚úì Uploaded</div>
      </div>

      <!-- Quantity -->
      <div class="upload-area" id="area-quantity" data-column="quantity">
        <button class="upload-clear-btn" onclick="clearUpload('quantity', event)">√ó</button>
        <div class="upload-icon">
          <i data-lucide="upload"></i>
        </div>
        <div class="upload-label">Quantity <span class="required">*</span></div>
        <input type="file" id="upload-quantity" accept="image/*" />
        <div class="file-status" id="status-quantity" style="display: none;">‚úì Uploaded</div>
      </div>

      <!-- Description -->
      <div class="upload-area" id="area-description" data-column="description">
        <button class="upload-clear-btn" onclick="clearUpload('description', event)">√ó</button>
        <div class="upload-icon">
          <i data-lucide="upload"></i>
        </div>        
        <div class="upload-label" id="label-description">Description</div>
        <input type="file" id="upload-description" accept="image/*" />
        <div class="file-status" id="status-description" style="display: none;">‚úì Uploaded</div>
      </div>

      <!-- Material -->
      <div class="upload-area" id="area-material" data-column="material">
        <button class="upload-clear-btn" onclick="clearUpload('material', event)">√ó</button>
        <div class="upload-icon">
          <i data-lucide="upload"></i>
        </div>        
        <div class="upload-label">Material</div>
        <input type="file" id="upload-material" accept="image/*" />
        <div class="file-status" id="status-material" style="display: none;">‚úì Uploaded</div>
      </div>
    </div>

    <div style="text-align: right; margin: 20px 0 10px 0;">
      <div style="display: flex; align-items: center; justify-content: flex-end; gap: 10px;">
        <div id="process-status" style="display: none; color: #808080; font-size: 0.9rem;">
          <span id="status-icon">‚è≥</span> <span id="status-text">Processing...</span>
        </div>
        <button id="process-btn">Process Image</button>
      </div>
    </div>


    <div id="image-preview">
<!--       <button class="preview-remove-btn" onclick="clearPreview()" style="display: none;">√ó</button> -->
      <div id="sample-preview">
        <strong>Sample Screenshot</strong><br>
        <img src= "sample-screenshot.png" alt="Sample column screenshot">
      </div>    
    </div>

    <div style="text-align: right; margin: 20px 0 10px 0;">
      <div style="display: flex; align-items: center; justify-content: flex-end; gap: 10px;">
        <div id="add-data-status" style="display: none; color: #007bff; font-size: 0.9rem;">
          <span id="add-status-icon">üì§</span> <span id="add-status-text">Adding Data...</span>
        </div>
        <button id="add-data-btn" style="display: none;">Add Data</button>
      </div>
    </div>
    
    <div id="result-container"></div>
    <button id="download-btn" class="secondary-button" style="display: none;">Download as CSV</button>
    <div id="hot" style="width: 100%; height: 400px; display: none;"></div>
    
  </div>

  <script>

    // :-----------------------------------------:
    //  Column key ‚Üí display title mapping
    // :-----------------------------------------:
    const COLUMN_TITLES = {
      PartNumber:            "Part Number",
      Quantity:              "Quantity",
      Description:           "Description",
      Material:              "Material",
      "Matched Childpart":   "Select Drawing Number",
      Type:                  "Type"
    };
    
    let spreadsheetData = [];
    let columnsList = [];
    let columnCount = 0;
    let hot;

    const uploads = {
      partNumber: document.getElementById("upload-partnumber"),
      description: document.getElementById("upload-description"),
      quantity: document.getElementById("upload-quantity"),
      material: document.getElementById("upload-material")
    };

    const columnOrder = [
      { id: "partNumber", label: "PartNumber" },
      { id: "description", label: "Description" },
      { id: "quantity", label: "Quantity" },
      { id: "material", label: "Material" }
    ];

    // Track which columns have new uploads since last processing
    let newUploads = {
      partNumber: false,
      description: false,
      quantity: false,
      material: false
    };
    
    let hasProcessedOnce = false; // Track if we've processed at least once
    
    // Similarity Matching functions
    // ============================================
    // SEQUENTIAL CHARACTER MATCHING (CORRECTED)
    // ============================================
    
    function sequentialCharacterMatch(partNumber, childPart) {
      if (!partNumber || !childPart) return 0;
      
      // Normalize inputs
      const part = partNumber.trim().toUpperCase();
      const child = childPart.trim().toUpperCase();
      
      // Exact match
      if (part === child) return 1.0;
      
      // Check if PartNumber exists as a substring anywhere in ChildPart
      if (child.includes(part)) {
        return 0.99; // Perfect substring match - PartNumber found anywhere in ChildPart
      }
      
      // Sequential character matching - find all characters of PartNumber in order
      let partIndex = 0;
      let childIndex = 0;
      let matchedChars = 0;
      
      // Go through each character in childPart
      while (childIndex < child.length && partIndex < part.length) {
        if (part[partIndex] === child[childIndex]) {
          matchedChars++;
          partIndex++;
        }
        childIndex++;
      }
      
      // üîß IMPROVED SIMILARITY: Add length penalty for very different lengths
      const baseSimilarity = matchedChars / part.length;
      
      // Apply length penalty only for significantly different lengths
      const lengthDiff = Math.abs(part.length - child.length);
      const lengthPenalty = lengthDiff > 1 ? (lengthDiff - 1) * 0.1 : 0;
      const similarity = Math.max(0, baseSimilarity - lengthPenalty);
      
      // Bonus if we found ALL characters of partNumber in order
      if (matchedChars === part.length) {
        return Math.max(0.85, similarity); // Minimum 0.85 for complete sequential match
      }
      
      return similarity;
    }
    
    function findBestSequentialMatch(partNumber, drawingNumbers) {
      if (!partNumber || !drawingNumbers || drawingNumbers.length === 0) {
        return {
          bestMatch: { target: '', rating: 0 },
          allMatches: []
        };
      }
      
      const matches = drawingNumbers.map(drawing => ({
        target: drawing,
        rating: sequentialCharacterMatch(partNumber, drawing)
      }));
      
      // Sort by similarity (highest first)
      matches.sort((a, b) => b.rating - a.rating);
      
      return {
        bestMatch: matches[0],
        allMatches: matches
      };
    }

    
    const API_URL = 'https://ocr-table-extractor.onrender.com';

    window.addEventListener("DOMContentLoaded", async () => {
      const urlParams = new URLSearchParams(window.location.search);
      const project = urlParams.get("project");
      const partNumber = urlParams.get("part");
      const parentDrgNum = urlParams.get("parentdrgnum");
      const currentTab = urlParams.get("current_tab"); // üîß ADD THIS LINE

      if (!project || !partNumber || !parentDrgNum || !currentTab ) {
        alert("Missing query params: project/part/parent drawing number/currentTab");
        return;
      }

      // Store currentTab globally for use in upload area naming
      window.currentTab = currentTab; // üîß ADD THIS LINE 
      
      try {
        const response = await fetch("https://ocr-table-extractor.onrender.com/fetch-drawings", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ project, part: partNumber })
        });
        const data = await response.json();
        console.log("‚úÖ Filtered drawing data from Glide via backend:", data.rows);
        window.childParts = data.rows;
      } catch (err) {
        console.error("‚ùå Error fetching drawing data:", err);
      }

      // Update labels based on current tab
      updateUploadLabels(); // üîß ADD THIS LINE
    });

    function textRenderer(instance, td, row, col, prop, value, cellProperties) {
      Handsontable.renderers.TextRenderer.apply(this, arguments);
      const rowData = instance.getSourceDataAtRow(row);
      if (rowData && rowData[prop] && typeof rowData[prop] === 'object') {
        const cellData = rowData[prop];
        td.innerText = cellData.text;
        const conf = parseFloat(cellData.confidence);
        if (conf >= 0.9) td.style.backgroundColor = 'rgba(76, 175, 80, 0.2)';
        else if (conf >= 0.7) td.style.backgroundColor = 'rgba(255, 152, 0, 0.2)';
        else td.style.backgroundColor = 'rgba(244, 67, 54, 0.2)';
      } else {
        td.innerText = value;
      }
    }

    function renderSpreadsheet() {
      // ensure the new column is in the right spot
      if (columnsList.includes("Matched Childpart") && !columnsList.includes("Type")) {
        const idx = columnsList.indexOf("Matched Childpart");
        columnsList.splice(idx + 1, 0, "Type");
      }
      
      const columns = [];
      const colHeaders = [];
    
      columnsList.forEach(key => {
        const title = COLUMN_TITLES[key] || key;
        const isMatched = key === 'Matched Childpart';
        const isType    = key === "Type";
        const drawingOptions = Array.isArray(window.childParts)
          ? window.childParts.map(p => decodeURIComponent(p.drawingNumber || ''))
          : [];
    
        columns.push({
          // 1) editor & data binding
          data:       (isMatched || isType) ? key : `${key}.text`,
          title,
          type:       (isMatched || isType) ? 'dropdown' : 'text',
          // editor:     (isMatched || isType) ? 'dropdown' : 'text',
          editor: isMatched ? 'autocomplete' : isType ? 'dropdown' : 'text',
          source:     isMatched ? ['', ...drawingOptions] : isType ? ['', 'Child Part','BO'] : undefined, // Add empty option first
          strict:     false, // Allow free text for both dropdown columns
          allowInvalid: true, // Allow invalid/empty values for both columns
          // filter:     (isMatched || isType) ? 'dropdown' : false, // Enable dropdown filtering
          // trimDropdown: false, // Show all options initially


          
              // 2) custom renderer for OCR columns
          renderer: (isMatched || isType)
            ? function(hotInst, td, row, col, prop, value, cellProps) {
                // Default dropdown renderer
                Handsontable.renderers.DropdownRenderer.apply(this, arguments);
                
                // Add low similarity warning for Matched Childpart
                if (isMatched && value && value.trim() !== '') {
                  const rowData = hotInst.getSourceDataAtRow(row);
                  const partNumberData = rowData['PartNumber'];
                  
                  if (partNumberData && partNumberData.text && window.childParts?.length) {
                    const drawingNumbers = window.childParts.map(p => decodeURIComponent(p.drawingNumber || ''));
                    const result = findBestSequentialMatch(partNumberData.text, drawingNumbers);
                    
                    // Check if current value matches the best match and get its similarity
                    let similarity = 0;
                    if (result.bestMatch.target === value) {
                      similarity = result.bestMatch.rating;
                    } else {
                      // If it's not the best match, find similarity for current value
                      const currentMatch = sequentialCharacterMatch(partNumberData.text, value);
                      similarity = currentMatch;
                    }
                    
                    console.log(`Similarity for "${value}": ${similarity}`); // Debug log
                    // Add this right before the similarity check:
                    console.log(`Rendering ${value}, similarity: ${similarity}, classes: ${td.className}`);

                    // Show warning for ALL non-perfect matches
                    if (similarity < 0.95) {
                      td.classList.add('low-similarity-cell');
                    } else {
                      td.classList.remove('low-similarity-cell');
                    }
                  }
                } else {
                  td.classList.remove('low-similarity-cell');
                }
              }
            : function(hotInst, td, row, col, prop, value, cellProps) {
                // first draw the text
                Handsontable.renderers.TextRenderer.apply(this, arguments);
    
                // then pull the original object back out
                const rowData = hotInst.getSourceDataAtRow(row);
                const cellObj = rowData[key];  // the {text, confidence} you stored
    
                if (cellObj && typeof cellObj === 'object') {
                  const conf = parseFloat(cellObj.confidence);
                  if (conf >= 0.95) {
                    td.style.backgroundColor = 'rgba(76, 175, 80, 0.2)';
                  } else if (conf >= 0.8) {
                    td.style.backgroundColor = 'rgba(255, 152, 0, 0.2)';
                  } else {
                    td.style.backgroundColor = 'rgba(244, 67, 54, 0.2)';
                  }
                }
              }
        });
    
        colHeaders.push(key);
      });
    
      const container = document.getElementById('hot');
      container.style.display = 'block';
      
      // Show the Add Data button when spreadsheet is rendered
      document.getElementById('add-data-btn').style.display = 'inline-block';

    
      if (hot) hot.destroy();
      hot = new Handsontable(container, {
        data: spreadsheetData,
        columns,
        colHeaders,
        rowHeaders: true,
        minSpareRows: 1,
        contextMenu: ['remove_row','copy','paste'],
        licenseKey: 'non-commercial-and-evaluation',
        dropdownMenu: true, // Enable dropdown menu
        filters: true, // Enable filtering
        // Add autocomplete settings for better dropdown filtering
        autoColumnSize: true,

        // üîß FIX: Proper selection management
        outsideClickDeselects: true,

  // Add this debug hook
afterSelectionEnd: function(row, column, row2, column2) {
  // Simple fix: directly modify the border elements
  setTimeout(() => {
    const currentBorders = document.querySelectorAll('.wtBorder.current[style*="display: block"]');
    currentBorders.forEach(border => {
      const style = border.getAttribute('style');
      
      // Fix width: 4 to width: 1
      if (style.includes('width: 4')) {
        border.setAttribute('style', style.replace('width: 4px', 'width: 1px'));
      }
      
      // Fix height: 4 to height: 1  
      if (style.includes('height: 4')) {
        border.setAttribute('style', style.replace('height: 4px', 'height: 1px'));
      }
    });
  }, 0);
}

        // // üîß FIX: Clean cell rendering without selection interference
        // afterRender: function() {
        //   // Force clear any stuck borders after each render
        //   setTimeout(() => {
        //     const stuckBorders = document.querySelectorAll('.wtBorder.current, .wtBorder.area');
        //     stuckBorders.forEach(border => {
        //       const rect = border.getBoundingClientRect();
        //       // If border has no dimensions or is positioned oddly, it's likely stuck
        //       if (rect.width === 0 || rect.height === 0 || rect.top < 0 || rect.left < 0) {
        //         border.style.display = 'none';
        //       }
        //     });
        //   }, 10);
        // }
        
        // // Remove the current afterSelectionEnd hook entirely and replace with:
        // afterSelection: function(row, column, row2, column2, preventScrolling, selectionLayerLevel) {
        //   // This fires when selection starts - more reliable than afterSelectionEnd
        //   // Clear any stuck selections from previous interactions
        //   if (selectionLayerLevel === 0) { // Only handle primary selections
        //     // Let Handsontable handle selection normally
        //     return;
        //   }
        // },
        
        // afterDeselect: function() {
        //   // This fires when a cell is deselected - perfect for cleanup
        //   // Force clear any stuck border states
        //   setTimeout(() => {
        //     const borders = document.querySelectorAll('.wtBorder');
        //     borders.forEach(border => {
        //       if (border.style.display !== 'none') {
        //         // Only hide if it appears stuck (no active selection)
        //         const activeCell = hot.getActiveEditor();
        //         if (!activeCell || !activeCell.isOpened()) {
        //           border.style.display = 'none';
        //         }
        //       }
        //     });
        //   }, 50);
        // }        
                
        // Prevent auto-selection in dropdowns
        // afterSelectionEnd: function(row, column, row2, column2) {
        //   const prop = hot.colToProp(column);
        //   if (prop === 'Matched Childpart' || prop === 'Type') {
        //     // Don't auto-select first item when opening dropdown
        //     const editor = hot.getActiveEditor();
        //     if (editor && editor.isOpened && editor.isOpened()) {
        //       editor.focus();
        //     }
        //   }
        // },
      });
      
      // Enhanced change handler
      hot.addHook('afterChange', (changes, source) => {
        // only care about real user edits
        if (source !== 'edit' || !changes) return;
      
        changes.forEach(([row, prop, oldValue, newValue]) => {
          // skip if value didn't actually change
          if (oldValue === newValue) return;
      
          const col = hot.propToCol(prop);
          // mark this cell as edited
          hot.setCellMeta(row, col, 'className', 'edited-cell');
          
          // Handle Type column auto-population when Matched Childpart changes
          if (prop === 'Matched Childpart') {
            const typeCol = hot.propToCol('Type');
            if (typeCol !== -1) {
              // Only auto-populate Type if user didn't explicitly set it to empty
              if (newValue && newValue.trim() !== '') {
                hot.setDataAtCell(row, typeCol, 'Child Part', 'auto-type-population');
              } else if (newValue === '' || newValue === null) {
                // Don't auto-populate when user clears the field
                hot.setDataAtCell(row, typeCol, 'BO', 'auto-type-population');
              }
            }
          }
        });
      
        // re-render so every flagged cell gets the CSS
        hot.render();
      });
    }

    function addColumn(newColumnData, label) {
      // üîß FIX: If column already exists, remove it first (replacement)
      const existingIndex = columnsList.indexOf(label);
      if (existingIndex > -1) {
        console.log(`Replacing existing column: ${label}`);
        // Clear existing data for this column
        spreadsheetData.forEach(row => {
          if (row[label]) {
            delete row[label];
          }
        });
      } else {
        // Only add to columnsList if it's truly new
        columnsList.push(label);
      }
      
      if (label === "PartNumber" && !columnsList.includes("Matched Childpart")) {
        columnsList.push("Matched Childpart");
        columnsList.push("Type");
      }

      for (let i = 0; i < newColumnData.length; i++) {
        const text = newColumnData[i].text || "";
        const confidence = newColumnData[i].confidence || 0;
        if (!spreadsheetData[i]) spreadsheetData[i] = {};
        spreadsheetData[i][label] = { text, confidence };

          // üîç DEBUG: Check what's being stored
        console.log(`Row ${i}, ${label}:`, {
          text: text,
          confidence: confidence,
          storedData: spreadsheetData[i][label]
        });

        if (label === "PartNumber" && window.childParts?.length) {
          const drawingNumbers = window.childParts.map(p => decodeURIComponent(p.drawingNumber || ""));
          const result = findBestSequentialMatch(text, drawingNumbers);
          const matchText = result.bestMatch.rating > 0.85 ? result.bestMatch.target : "";
          
          // Store both the match and similarity score for later use
          spreadsheetData[i]["Matched Childpart"] = matchText;
          spreadsheetData[i]["_similarityScore"] = result.bestMatch.rating; // Store for reference
          
          // Type cell: auto‚Äêpopulate
          // only set Type if there's actually a PartNumber
          if (text) {
            spreadsheetData[i]["Type"] = matchText ? "Child Part" : "BO";
          }
        }

       //  for (let i = newColumnData.length; i < spreadsheetData.length; i++) {
       //    // only if there's really a PartNumber in that row
       //    const part = spreadsheetData[i]["PartNumber"]?.text;
       //    if (part) {
       //      const hasMatch = spreadsheetData[i]["Matched Childpart"]?.text;
       //      spreadsheetData[i]["Type"] = hasMatch ? "Child Part" : "BO";
       //    }
       // }
      }

      renderSpreadsheet();
    }

document.getElementById("process-btn").onclick = async function () {
  // üîß NEW: Get status elements and show extracting status
  const processBtn = document.getElementById("process-btn");
  const statusDiv = document.getElementById("process-status");
  const statusIcon = document.getElementById("status-icon");
  const statusText = document.getElementById("status-text");

  // Show extracting status and disable button immediately
  processBtn.disabled = true;
  statusDiv.style.display = "inline-block";
  statusIcon.textContent = "‚è≥";
  statusText.textContent = "Processing...";

  try {
    // Determine which columns to process (UNCHANGED)
    const columnsToProcess = columnOrder.filter(col => {
      // First time: process all uploaded columns
      if (!hasProcessedOnce) {
        return uploads[col.id].files[0];
      }
      // Subsequent times: only process columns with new uploads
      return newUploads[col.id] && uploads[col.id].files[0];
    });

    console.log("Processing columns:", columnsToProcess.map(c => c.id));

    // üîß ADD THIS LINE:
    let hasAnySuccess = false;  
    
    // Processing loop (UNCHANGED)
    for (const col of columnsToProcess) {
      const fileInput = uploads[col.id];
      const file = fileInput.files[0];
      
      // Check required fields (only on first run)
      if (!hasProcessedOnce && !file && (col.id === "partNumber" || col.id === "quantity")) {
        alert(`Please upload an image for ${col.label}`);
        // üîß MODIFIED: Hide status on early return
        statusDiv.style.display = "none";
        processBtn.disabled = false;
        return;
      }
      
      // Skip if no file
      if (!file) {
        console.log(`‚è≠Ô∏è Skipping ${col.id} - no file uploaded`);
        continue;
      }

      const formData = new FormData();
      formData.append("image", file);
      formData.append("mode", "table");
      formData.append("column", col.id);

      console.log(`üöÄ OCR request for column: ${col.id}`);

      // OCR processing (UNCHANGED)
      const response = await fetch(API_URL, {
        method: "POST",
        body: formData
      });

      const data = await response.json();
      console.log(`‚úÖ OCR response for ${col.id}:`, data);
      
      if (data.table && Array.isArray(data.table)) {
        addColumn(data.table, col.label);
        hasAnySuccess = true; // üîß ADD THIS LINE
      } else {
        console.warn(`‚ö†Ô∏è No table data returned for ${col.id}`);
      }
    }
    
    statusIcon.textContent = "‚úÖ";
    statusText.textContent = "Processed!";

    // üîß SAFE: Hide preview with error checking
    try {
      if (previewContainer) {
        previewContainer.innerHTML = '';
        previewContainer.style.display = 'none';
        if (previewContainer.classList.contains('has-image')) {
          previewContainer.classList.remove('has-image');
        }
        if (previewContainer.dataset.lastColumn) {
          previewContainer.dataset.lastColumn = '';
        }
      }
      
      const samplePreview = document.getElementById('sample-preview');
      if (samplePreview) {
        samplePreview.style.display = 'none';
      }
    } catch (previewError) {
      console.log('Preview hiding error (safe to ignore):', previewError);
    } 

    // Hide status after 2 seconds
    setTimeout(() => {
      statusDiv.style.display = "none";
    }, 2000);        

  } catch (error) {
    console.error(`‚ùå Error processing:`, error);
    
    // üîß NEW: Show error status
    statusIcon.textContent = "‚ùå";
    statusText.textContent = "Failed!";
    
    // Hide status after 3 seconds
    setTimeout(() => {
      statusDiv.style.display = "none";
    }, 3000);
    
  } finally {
    // Reset tracking after processing (UNCHANGED)
    Object.keys(newUploads).forEach(key => {
      newUploads[key] = false;
    });
    hasProcessedOnce = true;
    updateProcessButton(); // This will set proper enabled/disabled state
  }
};
    
    //  document.getElementById("process-btn").onclick = async function () {
    //   // Determine which columns to process
    //   const columnsToProcess = columnOrder.filter(col => {
    //     // First time: process all uploaded columns
    //     if (!hasProcessedOnce) {
    //       return uploads[col.id].files[0];
    //     }
    //     // Subsequent times: only process columns with new uploads
    //     return newUploads[col.id] && uploads[col.id].files[0];
    //   });
    
    //   console.log("Processing columns:", columnsToProcess.map(c => c.id));
    
    //   for (const col of columnsToProcess) {
    //     const fileInput = uploads[col.id];
    //     const file = fileInput.files[0];
        
    //     // Check required fields (only on first run)
    //     if (!hasProcessedOnce && !file && (col.id === "partNumber" || col.id === "quantity")) {
    //       alert(`Please upload an image for ${col.label}`);
    //       return;
    //     }
        
    //     // Skip if no file
    //     if (!file) {
    //       console.log(`‚è≠Ô∏è Skipping ${col.id} - no file uploaded`);
    //       continue;
    //     }
    
    //     const formData = new FormData();
    //     formData.append("image", file);
    //     formData.append("mode", "table");
    //     formData.append("column", col.id);
    
    //     console.log(`üöÄ OCR request for column: ${col.id}`);
    
    //     try {
    //       const response = await fetch(API_URL, {
    //         method: "POST",
    //         body: formData
    //       });
    
    //       const data = await response.json();
    //       console.log(`‚úÖ OCR response for ${col.id}:`, data);
          
    //       if (data.table && Array.isArray(data.table)) {
    //         addColumn(data.table, col.label);
    //       } else {
    //         console.warn(`‚ö†Ô∏è No table data returned for ${col.id}`);
    //       }
    //     } catch (error) {
    //       console.error(`‚ùå Error processing ${col.id}:`, error);
    //       console.log(`Continuing with other columns...`);
    //     }
    //   }
    
    //   // üîß NEW: Reset tracking after processing
    //   Object.keys(newUploads).forEach(key => {
    //     newUploads[key] = false;
    //   });
    //   hasProcessedOnce = true;
    //   updateProcessButton(); // This will disable the button
    // };  
    

    const previewContainer = document.getElementById("image-preview");

    // Drag and drop functionality
    let dragCounter = 0;

    // Get nearest upload area based on mouse position
    function getNearbyUploadArea(x, y, threshold = 60) {
      const areas = document.querySelectorAll('.upload-area');
      let closestArea = null;
      let minDistance = threshold;
      
      areas.forEach(area => {
        const rect = area.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        // Calculate distance to center
        const distance = Math.sqrt(
          Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2)
        );
        
        // Also check if cursor is within extended bounds (for corners/edges)
        const extendedRect = {
          left: rect.left - 30,
          right: rect.right + 30,
          top: rect.top - 30,
          bottom: rect.bottom + 30
        };
        
        const withinExtendedBounds = x >= extendedRect.left && x <= extendedRect.right &&
                                   y >= extendedRect.top && y <= extendedRect.bottom;
        
        if ((distance < minDistance || withinExtendedBounds) && distance < 150) {
          minDistance = distance;
          closestArea = area;
        }
      });
      
      return closestArea;
    }

    // Clear all nearby highlights
    function clearNearbyHighlights() {
      document.querySelectorAll('.upload-area.nearby').forEach(area => {
        area.classList.remove('nearby');
      });
    }

    function clearAllDragStates() {
      document.querySelectorAll('.upload-area').forEach(area => {
        area.classList.remove('dragover', 'nearby');
      });
    }

    // Global drag events for vicinity detection
    document.addEventListener('dragenter', function(e) {
      e.preventDefault();
      dragCounter++;
    });

    document.addEventListener('dragover', function(e) {
      e.preventDefault();
      
      // Check if we're dragging files
      const hasFiles = e.dataTransfer && (
        e.dataTransfer.types.includes('Files') || 
        e.dataTransfer.types.includes('application/x-moz-file')
      );
      
      if (hasFiles) {
        // Set the drop effect
        e.dataTransfer.dropEffect = 'copy';
        
        const nearbyArea = getNearbyUploadArea(e.clientX, e.clientY);
        
        clearNearbyHighlights();
        if (nearbyArea && !nearbyArea.classList.contains('dragover')) {
          nearbyArea.classList.add('nearby');
        }
      }
    });

    document.addEventListener('dragleave', function(e) {
      dragCounter--;
      if (dragCounter <= 0) {
        dragCounter = 0;
        // Add a small delay to prevent flickering
        setTimeout(() => {
          if (dragCounter === 0) {
            clearNearbyHighlights();
            
            // Force clear all stuck states
            clearAllDragStates();
          }
        }, 50);
      }
    });

    document.addEventListener('drop', function(e) {
      dragCounter = 0;
      clearNearbyHighlights();
      
      // Force clear all stuck states on any drop
      clearAllDragStates();
    });

    // Setup individual upload areas
    document.querySelectorAll('.upload-area').forEach(area => {
      const col = area.dataset.column;
      const input = uploads[col];

      if (!input) {
        console.error(`Input not found for column: ${col}`);
        return;
      }

      // Click to upload
      area.addEventListener('click', function(e) {
        // Don't trigger if clicking the clear button
        if (e.target.closest('.upload-clear-btn')) return;
        input.click();
      });

      // File input change
      input.addEventListener('change', function() {
        if (input.files[0]) {
          area.classList.add('has-file');
          document.getElementById(`status-${col}`).style.display = 'block';

          // üîß NEW: Mark this column as having new upload
          newUploads[col] = true;
          
          // Store which column was last uploaded for the clear function
          previewContainer.dataset.lastColumn = col;
          
          // Update preview and button state
          const columnName = area.querySelector('.upload-label').textContent.trim();
          showImagePreview(input.files[0], columnName);
          updateProcessButton();
        } else {
          // Reset to initial state when no file is chosen
          area.classList.remove('has-file');
          document.getElementById(`status-${col}`).style.display = 'none';
          updateProcessButton();
        }
      });

      // Drag events for individual areas
      area.addEventListener('dragenter', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        // Check if we have files being dragged
        if (e.dataTransfer.types.includes('Files')) {
          area.classList.add('dragover');
          clearNearbyHighlights();
        }
      });

      area.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        // Ensure we're handling files
        if (e.dataTransfer.types.includes('Files')) {
          e.dataTransfer.dropEffect = 'copy';

          if (!area.classList.contains('dragover')) {
            area.classList.add('dragover');
          }
        }
      });

      area.addEventListener('dragleave', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        // Only remove dragover if we're actually leaving the area
        const rect = area.getBoundingClientRect();
        const x = e.clientX;
        const y = e.clientY;
        
        if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
          area.classList.remove('dragover');
        }
      });

      area.addEventListener('drop', function(e) {
        e.preventDefault();
        e.stopPropagation();
        area.classList.remove('dragover', 'nearby');
        clearAllDragStates();
        // clearNearbyHighlights();

        dragCounter = 0;
        // Ensure we have files and handle them properly
        if (e.dataTransfer.files.length > 0) {
          const dt = new DataTransfer();
          for (let i = 0; i < e.dataTransfer.files.length; i++) {
            dt.items.add(e.dataTransfer.files[i]);
          }
          input.files = dt.files;
          
          // Trigger change event manually to ensure all handlers run
          const changeEvent = new Event('change', { bubbles: true });
          input.dispatchEvent(changeEvent);
        }
      });
    });

    // Enable/disable process button based on required files
    function updateProcessButton() {
      const hasRequired = uploads.partNumber.files.length > 0 && uploads.quantity.files.length > 0;
      const hasNewUploads = Object.values(newUploads).some(isNew => isNew);
      
      // Enable if: has required files AND (first time OR has new uploads)
      const shouldEnable = hasRequired && (!hasProcessedOnce || hasNewUploads);
      
      document.getElementById("process-btn").disabled = !shouldEnable;

      // üîç DEBUG: Log button state
      console.log("Process button state:", {
        hasRequired,
        hasNewUploads,
        hasProcessedOnce,
        shouldEnable
      });    
    }

    // Initialize button state
    updateProcessButton();
    
    // Preview function with remove button
    function showImagePreview(file, label) {
      const reader = new FileReader();
      reader.onload = function (event) {
        const img = new Image();
        img.src = event.target.result;
        // img.style.maxWidth = "300px";
        img.alt = label;

        // üîß ADD: Show container if it was hidden
        previewContainer.style.display = 'block';     

        // Safely hide sample preview (check if it exists first)
        const samplePreview = document.getElementById('sample-preview');
        if (samplePreview) {
          samplePreview.style.display = 'none';
        }
        
        // // show remove button
        // document.querySelector('.preview-remove-btn').style.display = 'flex';
        // <button class="preview-remove-btn" onclick="clearPreview()">√ó</button>
        
        // Clear previous preview and insert new one
        previewContainer.innerHTML = `<strong>${label}</strong><br>`;
        previewContainer.appendChild(img);
        previewContainer.classList.add('has-image');
      };
      reader.readAsDataURL(file);
    }

    // Function to clear preview and reset corresponding upload
    function clearPreview() {
      // Get the last column BEFORE clearing it
      const lastUploadedColumn = previewContainer.dataset.lastColumn;
      
      previewContainer.innerHTML = `
        <button class="preview-remove-btn" onclick="clearPreview()" style="display: none;">√ó</button>
        
        <div id="sample-preview">
          <strong>Sample Column Screenshot</strong><br>
          <img src= "sample-screenshot.png" alt="Sample column screenshot">
        </div>
      `;
        
      previewContainer.classList.remove('has-image');
      previewContainer.dataset.lastColumn = ''; // <-- This is needed!
      
      // Find and clear the last uploaded file
      if (lastUploadedColumn) {
        const input = uploads[lastUploadedColumn];
        if (input) {
          input.value = '';
          document.getElementById(`area-${lastUploadedColumn}`).classList.remove('has-file');
          document.getElementById(`status-${lastUploadedColumn}`).style.display = 'none';
          updateProcessButton();
        }
      }
    }

    // Function to clear specific upload area
    function clearUpload(columnId, event) {
      if (event) {
        event.stopPropagation(); // Prevent bubbling to parent upload area
      }

      const input = uploads[columnId];
      const area = document.getElementById(`area-${columnId}`);
      const status = document.getElementById(`status-${columnId}`);
      
      if (input) {
        input.value = '';
        area.classList.remove('has-file');
        status.style.display = 'none';

        // üîß NEW: Mark as no longer having new upload
        newUploads[columnId] = false;
        
        updateProcessButton();
        
        // Clear preview if this was the last uploaded file
        if (previewContainer.dataset.lastColumn === columnId) {
          clearPreview();
          // previewContainer.innerHTML = '<button class="preview-remove-btn" onclick="clearPreview()">√ó</button>';
          // previewContainer.classList.remove('has-image');
          // previewContainer.dataset.lastColumn = '';
        }
      }
    }

    // Make clearPreview and clearUpload globally accessible
    window.clearPreview = clearPreview;
    window.clearUpload = clearUpload;

    
    // Post Data to Backend 
    // Function to send data to backend
async function sendDataToBackend() {
  // Get elements
  const addDataBtn = document.getElementById("add-data-btn");
  const addDataStatusDiv = document.getElementById("add-data-status");  // Different from process-status
  const addStatusIcon = document.getElementById("add-status-icon");      // Different from status-icon
  const addStatusText = document.getElementById("add-status-text"); 

  // Store original button text
  const originalBtnText = addDataBtn.textContent;
  
  try {
    // Show loading immediately
    addDataBtn.disabled = true;
    addDataStatusDiv.style.display = "inline-block";
    addStatusIcon.textContent = "üì§";
    addStatusText.textContent = "Adding Data...";

    // Validation with status feedback
    const validation = validateRequiredFields();
    if (!validation.isValid) {
      addStatusIcon.textContent = "‚ö†Ô∏è";
      addStatusText.textContent = "Validation Failed!";
      
      // Show validation error popup
      alert(`Missing Required Fields: ${validation.missingFields.join(', ')}\n\nRequired fields:\n- Part Number, Quantity, Type (always required)\n- Select Drawing Number (required when Type is "Child Part")`);
      
      // Hide status after showing error
      setTimeout(() => {
        addDataStatusDiv.style.display = "none";
      }, 3000);
      return;
    }

    // Get URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const project = urlParams.get("project");
    const parentDrawingNumber = urlParams.get("parentdrgnum");
    const partNumber = urlParams.get("part");

    if (!project || !parentDrawingNumber || !partNumber) {
      throw new Error("Missing project, parent drawing number, or part number information");
    }

    // Separate data by Type
    const childPartsData = [];
    const boData = [];

    spreadsheetData.forEach((row, index) => {
      const frontendPartNumber = row.PartNumber?.text?.trim();
      const quantity = row.Quantity?.text?.trim();
      const type = row.Type?.trim();
      
      if (!frontendPartNumber || !quantity || !type) return;

      if (type === 'Child Part') {
        const childRowData = {
          quantity: quantity,
          description: row.Description?.text?.trim() || '',
          material: row.Material?.text?.trim() || '',
          drawingNumber: row['Matched Childpart'] || '',
        };
        childPartsData.push(childRowData);
        
      } else if (type === 'BO') {
        const matchedDrawingNumber = row['Matched Childpart']?.trim();
        const boRowData = {
          quantity: quantity,
          description: row.Description?.text?.trim() || '',
          material: row.Material?.text?.trim() || '',
          boughtoutPartNumber: matchedDrawingNumber || frontendPartNumber,
        };
        boData.push(boRowData);
      }
    });

    // Update status for sending
    addStatusIcon.textContent = "üîÑ";
    addStatusText.textContent = "Sending to Database...";

    let successfulRequests = 0;
    let totalRequests = 0;

    // Send Child Parts data
    if (childPartsData.length > 0) {
      totalRequests++;
      console.log('üöÄ Sending Child Parts data to backend...');
      
      const childResponse = await fetch('https://ocr-table-extractor.onrender.com/add-child-parts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          rows: childPartsData,
          project: project,
          parentDrawingNumber: parentDrawingNumber,
          partNumber: partNumber
        })
      });
      
      if (!childResponse.ok) {
        const errorData = await childResponse.text();
        throw new Error(`Failed to add Child Parts: ${errorData}`);
      }
      
      // Wait for and validate response
      const childResult = await childResponse.json();
      console.log('‚úÖ Child Parts added successfully:', childResult);
      successfulRequests++;
    }

    // Send BO data
    if (boData.length > 0) {
      totalRequests++;
      console.log('üöÄ Sending BO data to backend...');
      
      const boResponse = await fetch('https://ocr-table-extractor.onrender.com/add-bo-parts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          rows: boData,
          project: project,
          parentDrawingNumber: parentDrawingNumber,
          partNumber: partNumber
        })
      });
      
      if (!boResponse.ok) {
        const errorData = await boResponse.text();
        throw new Error(`Failed to add BO Parts: ${errorData}`);
      }
      
      // Wait for and validate response
      const boResult = await boResponse.json();
      console.log('‚úÖ BO Parts added successfully:', boResult);
      successfulRequests++;
    }

    // Success only after ALL requests complete
    if (successfulRequests === totalRequests && totalRequests > 0) {
      addStatusIcon.textContent = "‚úÖ";
      addStatusText.textContent = "Added Successfully!";
      
      // Success popup with actual data
      alert(`Data added successfully!\n- Child Parts: ${childPartsData.length}\n- BO Parts: ${boData.length}`);
      
      // Hide status after success
      setTimeout(() => {
        addDataStatusDiv.style.display = "none";
      }, 3000);
    } else {
      throw new Error("No data was processed");
    }
    
  } catch (error) {
    console.error('‚ùå Error sending data:', error);
    
    // Error status
    addStatusIcon.textContent = "‚ùå";
    addStatusText.textContent = "Addition Failed!";
    
    // Error popup
    alert(`Error adding data: ${error.message}`);
    
    // Hide status after error
    setTimeout(() => {
      addDataStatusDiv.style.display = "none";
    }, 3000);
    
  } finally {
    // Always re-enable button
    addDataBtn.disabled = false;
  }
}

    
    // async function sendDataToBackend() {
    //   // Validate required fields first
    //   const validation = validateRequiredFields();
    //   if (!validation.isValid) {
    //     alert(`Missing Required Fields: ${validation.missingFields.join(', ')}\n\nRequired fields: Part Number, Quantity, and Type`);
    //     return;
    //   }
    
    //   // Get URL parameters (needed for backend)
    //   const urlParams = new URLSearchParams(window.location.search);
    //   const project = urlParams.get("project");
    //   const parentDrawingNumber = urlParams.get("parentdrgnum");
    //   const partNumber = urlParams.get("part"); // This is the actual Part Number for DB
    
    //   if (!project || !parentDrawingNumber || !partNumber) {
    //     alert("Missing project, parent drawing number, or part number information");
    //     return;
    //   }
    
    //   // Separate data by Type
    //   const childPartsData = [];
    //   const boData = [];
    
    //   spreadsheetData.forEach((row, index) => {
    //     // Skip empty rows
    //     const frontendPartNumber = row.PartNumber?.text?.trim(); // Used for reference/matching
    //     const quantity = row.Quantity?.text?.trim();
    //     const type = row.Type?.trim();
        
    //     if (!frontendPartNumber || !quantity || !type) return;
    
    //     if (type === 'Child Part') {
    //       // Child Parts data (frontend Part Number NOT included)
    //       const childRowData = {
    //         quantity: quantity,
    //         description: row.Description?.text?.trim() || '',
    //         material: row.Material?.text?.trim() || '',
    //         drawingNumber: row['Matched Childpart'] || '', // Select Drawing Number
    //       };
    //       childPartsData.push(childRowData);
          
    //     } else if (type === 'BO') {
    //       // BO data with special logic for Boughtout Part number
    //       const matchedDrawingNumber = row['Matched Childpart']?.trim();
          
    //       const boRowData = {
    //         quantity: quantity,
    //         description: row.Description?.text?.trim() || '',
    //         material: row.Material?.text?.trim() || '', // This goes to MOC field
    //         // Logic: Use Drawing Number if found, otherwise use Frontend Part Number
    //         boughtoutPartNumber: matchedDrawingNumber || frontendPartNumber,
    //       };
    //       boData.push(boRowData);
    //     }
    //   });
    
    //   console.log(`üìä Data prepared: ${childPartsData.length} Child Parts, ${boData.length} BO Parts`);
    
    //   // Show confirmation dialog
    //   const confirmMessage = `Ready to submit:\n- Child Parts: ${childPartsData.length}\n- BO Parts: ${boData.length}\n\nProceed?`;
    //   if (!confirm(confirmMessage)) {
    //     return;
    //   }
    
    //   try {
    //     // Send Child Parts data
    //     if (childPartsData.length > 0) {
    //       console.log('üöÄ Sending Child Parts data to backend...');
    //       const childResponse = await fetch('https://ocr-table-extractor.onrender.com/add-child-parts', {
    //         method: 'POST',
    //         headers: { 'Content-Type': 'application/json' },
    //         body: JSON.stringify({ 
    //           rows: childPartsData,
    //           project: project,
    //           parentDrawingNumber: parentDrawingNumber,
    //           partNumber: partNumber // Actual Part Number for DB from URL
    //         })
    //       });
    
    //       const childResult = await childResponse.json();
    //       if (!childResponse.ok) {
    //         throw new Error(`Child Parts: ${childResult.error || 'Unknown error'}`);
    //       }
    //       console.log('‚úÖ Child Parts added successfully: ', childResult);
    //     }
    
    //     // Send BO data
    //     if (boData.length > 0) {
    //       console.log('üöÄ Sending BO data to backend...');
    //       const boResponse = await fetch('https://ocr-table-extractor.onrender.com/add-bo-parts', {
    //         method: 'POST',
    //         headers: { 'Content-Type': 'application/json' },
    //         body: JSON.stringify({ 
    //           rows: boData,
    //           project: project,
    //           parentDrawingNumber: parentDrawingNumber,
    //           partNumber: partNumber // Overall Part Number for BO table
    //         })
    //       });
    
    //       const boResult = await boResponse.json();
    //       if (!boResponse.ok) {
    //         throw new Error(`BO Parts: ${boResult.error || 'Unknown error'}`);
    //       }
    //       console.log('‚úÖ BO Parts added successfully: ', boResult);
    //     }
    
    //     alert(`Data added successfully!\n- Child Parts: ${childPartsData.length}\n- BO Parts: ${boData.length}`);
        
    //   } catch (error) {
    //     console.error('‚ùå Error sending data:', error);
    //     alert(`Error adding data: ${error.message}`);
    //   }
    // }
    
    // Function to validate required fields
    function validateRequiredFields() {
      const missingFields = [];
      let hasValidRows = false;
    
      spreadsheetData.forEach((row, index) => {
        const partNumber = row.PartNumber?.text?.trim();
        const quantity = row.Quantity?.text?.trim();
        const type = row.Type?.trim();
    
        // Only skip rows if BOTH Part Number AND Quantity are missing
        // (because if either is present, user intended to add this row)
        if (!partNumber && !quantity) return;
    
        hasValidRows = true;
    
        // Check required fields for rows that have at least Part Number OR Quantity
        if (!partNumber) {
          missingFields.push(`Row ${index + 1}: Part Number`);
        }
        if (!quantity) {
          missingFields.push(`Row ${index + 1}: Quantity`);
        }
        if (!type || type === '') {
          missingFields.push(`Row ${index + 1}: Type`);
        }
        // üîß NEW: Additional validation for Child Part type
        if (type === 'Child Part') {
          const selectDrawingNumber = row['Matched Childpart']?.trim();
          if (!selectDrawingNumber || selectDrawingNumber === '') {
            missingFields.push(`Row ${index + 1}: Select Drawing Number (required when Type is "Child Part")`);
          }
        } 
      });
    
      return {
        isValid: hasValidRows && missingFields.length === 0,
        missingFields: missingFields
      };
    }

    // Function to update upload area labels based on current tab
    function updateUploadLabels() {
      const currentTab = window.currentTab;
      const partNumberLabel = document.getElementById('label-partNumber');
      const descriptionLabel = document.getElementById('label-description');
      
      if (currentTab === 'Boughouts') {
        partNumberLabel.innerHTML = 'Part Number / Description <span class="required">*</span>';
        descriptionLabel.textContent = 'Additional Description';
      } else {
        // Default for 'Child%20parts' or any other value
        partNumberLabel.innerHTML = 'Part Number <span class="required">*</span>';
        descriptionLabel.textContent = 'Description';
      }
    }    

    
    // Attach onchange handlers (keeping original preview functionality)
    uploads.partNumber.addEventListener("change", (e) => {
      if (e.target.files[0]) {
        previewContainer.dataset.lastColumn = 'partNumber';
        showImagePreview(e.target.files[0], "PartNumber Preview");
        updateProcessButton();
      }
    });
    uploads.quantity.addEventListener("change", (e) => {
      if (e.target.files[0]) {
        previewContainer.dataset.lastColumn = 'quantity';
        showImagePreview(e.target.files[0], "Quantity Preview");
        updateProcessButton();
      }
    });
    uploads.description.addEventListener("change", (e) => {
      if (e.target.files[0]) {
        previewContainer.dataset.lastColumn = 'description';
        showImagePreview(e.target.files[0], "Description Preview");
      }
    });
    uploads.material.addEventListener("change", (e) => {
      if (e.target.files[0]) {
        previewContainer.dataset.lastColumn = 'material';
        showImagePreview(e.target.files[0], "Material Preview");
      }
    });

    // Initialize Lucide icons
    lucide.createIcons();

    // Add Data button event listener
    document.getElementById('add-data-btn').addEventListener('click', sendDataToBackend);

    // Help icon click handler
    document.getElementById('help-icon').addEventListener('click', function(e) {
      e.stopPropagation();
      const popover = document.getElementById('help-popover');
      popover.style.display = popover.style.display === 'block' ? 'none' : 'block';
    });
    
    // Close popover when clicking anywhere else
    document.addEventListener('click', function(e) {
      const popover = document.getElementById('help-popover');
      const helpIcon = document.getElementById('help-icon');
      
      if (!popover.contains(e.target) && !helpIcon.contains(e.target)) {
        popover.style.display = 'none';
      }
    });   
    
  </script>
</body>
</html>
